// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema
// Database: Supabase Postgres

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User (Admin/Developer) 
// In "Team Mode", this is the Team Admin. 
// In "Fork Mode", this is the individual developer.
model User {
  id        String   @id @default(cuid())
  githubId  String   @unique
  email     String?
  name      String?
  avatarUrl String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  projects  Project[]
}

// A Connected Repository (Source of Truth)
model Project {
  id          String   @id @default(cuid())
  ownerId     String
  owner       User     @relation(fields: [ownerId], references: [id])
  
  // GitHub Info
  repoName    String   // e.g. "my-project"
  repoOwner   String   // e.g. "my-org"
  repoUrl     String
  githubRepoId Int     @unique // The unique ID from GitHub
  
  // Settings
  installationId String? // The GitHub App Installation ID
  
  rules       Rule[]
  analyses    Analysis[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// The Core: A Compliance Rule
model Rule {
  id          String   @id @default(cuid())
  projectId   String
  project     Project  @relation(fields: [projectId], references: [id])

  // The "English" definition
  description String   // e.g. "Variable names must be camelCase"
  language    String   // e.g. "javascript", "java", "python"

  // The "Tree-sitter" definition (Generated by AI, Verified by Admin)
  treeSitterQuery String  @db.Text // The actual Scheme-like query: (identifier) @name ...
  
  // AI Context
  aiExplanation   String? @db.Text // Why this query works (for Admin review)
  
  // Enforcement
  severity        Severity @default(WARNING)
  isActive        Boolean  @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Audit Log of Runs
model Analysis {
  id          String   @id @default(cuid())
  projectId   String
  project     Project  @relation(fields: [projectId], references: [id])
  
  prNumber    Int
  commitHash  String
  
  status      AnalysisStatus
  
  violations  Violation[]

  createdAt   DateTime @default(now())
}

model Violation {
  id          String   @id @default(cuid())
  analysisId  String
  analysis    Analysis @relation(fields: [analysisId], references: [id])
  
  ruleId      String?
  filePath    String
  lineNumber  Int
  message     String
  
  createdAt   DateTime @default(now())
}

enum Severity {
  WARNING
  CRITICAL // Creates Jira Ticket
}

enum AnalysisStatus {
  PENDING
  SUCCESS
  FAILURE
}

// ============================================================
// LANGUAGE-INDEPENDENT RULE ARCHITECTURE
// ============================================================

// Abstract Rule - Language-independent rule definition
// Defines WHAT to detect, not HOW (language-specific)
model AbstractRule {
  id          String       @id @default(cuid())
  name        String       @unique  // "no-eval", "no-hardcoded-secrets"
  displayName String                // "No Dynamic Code Execution"
  description String       @db.Text // English description
  category    RuleCategory
  severity    Severity     @default(WARNING)
  
  // Abstract pattern definition
  patternType   PatternType
  patternConfig Json        // { functionNames: [...], variablePattern: "...", etc }
  
  // Metadata
  tags        String[]     // ["security", "critical", "owasp"]
  isActive    Boolean      @default(true)
  
  // Relations
  generatedQueries GeneratedQuery[]
  
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

// Language Adapter - Maps abstract concepts to Tree-sitter node types
// One adapter per supported language
model LanguageAdapter {
  id              String   @id @default(cuid())
  language        String   @unique  // "javascript", "python", "java"
  displayName     String             // "JavaScript", "Python", "Java"
  fileExtensions  String[]           // [".js", ".jsx", ".mjs"]
  
  // Tree-sitter grammar info
  treeSitterGrammar String           // "tree-sitter-javascript"
  
  // Node type mappings (abstract concept → language-specific node type)
  nodeTypeMappings Json              // { "FUNCTION_CALL": "call_expression", ... }
  
  // Query templates (pattern type → template string)
  queryTemplates   Json              // { "FUNCTION_CALL_BY_NAME": "...", ... }
  
  // Language-specific config
  namingConvention String            // "camelCase", "snake_case", "PascalCase"
  
  // Relations
  generatedQueries GeneratedQuery[]
  
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Generated Query - Cached Tree-sitter query for rule+language combination
// Auto-generated from AbstractRule + LanguageAdapter
model GeneratedQuery {
  id          String   @id @default(cuid())
  
  ruleId      String
  rule        AbstractRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  
  languageId  String
  language    LanguageAdapter @relation(fields: [languageId], references: [id], onDelete: Cascade)
  
  // The actual Tree-sitter query
  treeSitterQuery String @db.Text
  
  // Validation status
  isValidated Boolean  @default(false)
  validatedAt DateTime?
  
  // Cache management
  generatedAt DateTime @default(now())
  
  @@unique([ruleId, languageId])
}

// Pattern types for abstract rules
enum PatternType {
  FUNCTION_CALL        // Detect specific function/method calls
  ASSIGNMENT           // Detect variable assignments matching pattern
  FUNCTION_DECLARATION // Detect function/method declarations
  CLASS_DECLARATION    // Detect class definitions
  TRY_CATCH           // Detect try-catch blocks
  IMPORT              // Detect import/require statements
  LOOP                // Detect loop constructs
  CONDITIONAL         // Detect if/switch statements
  LITERAL             // Detect specific literals
  BINARY_EXPRESSION   // Detect binary operations (==, !=, etc)
  MEMBER_ACCESS       // Detect property/method access
  COMMENT             // Detect comment patterns
}

enum RuleCategory {
  SECURITY
  NAMING
  STYLE
  BEST_PRACTICE
  PERFORMANCE
  ACCESSIBILITY
}

// Legacy model - kept for backward compatibility
// TODO: Migrate existing data to new architecture
model RuleTemplate {
  id          String   @id @default(cuid())
  name        String
  description String   @db.Text
  category    RuleCategory
  language    String
  treeSitterQuery String @db.Text
  severity    Severity @default(WARNING)
  tags        String[]
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
